{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import mysql.connector\n",
    "mydb=mysql.connector.connect(\n",
    "host=\"localhost\",\n",
    "user=\"username\",\n",
    "password=\"password\",\n",
    "database=\"database\")\n",
    "cursor = mydb.cursor()\n",
    "cursor.execute(\"select * from vw_DAT_ASCII__EURUSD_T_2\")\n",
    "#second dataset vw_DAT_ASCII_EURGBP_T_2\n",
    "result=cursor.fetchall()\n",
    "df=pd.DataFrame(result,columns=cursor.column_names)\n",
    "#print(df)\n",
    "\n",
    "\n",
    "def intrinsic_event_algo(df, column, dc_threshold):\n",
    "\n",
    "#Set up the extreme references, starting with first value and having 2 extreme references (a max and a min)until the first DC event\n",
    "reference_extreme = df.at[0, column]\n",
    "last_dc_direction = None\n",
    "dc_event = None\n",
    "dc_os_events = []\n",
    "init_min= df.at[0, column]\n",
    "init_max= df.at[0, column]\n",
    "\n",
    "for index, row in df.iterrows():\n",
    "curr_price = row[column]\n",
    "# Calculate price_change and see if it's greater than or equal to the DC threshold\n",
    "if last_dc_direction==None:\n",
    "price_change_min=(curr_price-init_min)/init_min\n",
    "price_change_max=(curr_price-init_max)/init_max\n",
    "is_dc = max(abs(price_change_max),abs(price_change_min))>= dc_threshold\n",
    "if abs(price_change_max)>=dc_threshold:\n",
    "price_change=price_change_max\n",
    "elif abs(price_change_min)>=dc_threshold:\n",
    "price_change=price_change_min\n",
    "else:\n",
    "price_change = (curr_price - reference_extreme) / reference_extreme\n",
    "is_dc = abs(price_change) >= dc_threshold\n",
    "\n",
    "if is_dc:\n",
    "direction = 'up' if price_change > 0 else 'down'\n",
    "\n",
    "# Check if the current direction is different from the last_dc_direction\n",
    "if direction != last_dc_direction:\n",
    "reference_extreme = curr_price\n",
    "dc_event = {\"timestamp\": row[\"timestamp\"], \"mid\": curr_price,\"bid\": row[\"bid\"],\"ask\": row[\"ask\"], \"type\": \"DC\", \"direction\": direction}\n",
    "if dc_event is not None:\n",
    "dc_os_events.append(dc_event)\n",
    "last_dc_direction = direction\n",
    "dc_event = None\n",
    "else:\n",
    "if last_dc_direction==None and curr_price >init_max:\n",
    "init_max=curr_price\n",
    "elif last_dc_direction==None and curr_price <init_min:\n",
    "init_min=curr_price\n",
    "if (last_dc_direction=='up'and curr_price>reference_extreme) or (last_dc_direction=='down' and curr_price<reference_extreme):\n",
    "reference_extreme=curr_price\n",
    "return pd.DataFrame(dc_os_events)\n",
    "\n",
    "# Example\n",
    "dc_threshold = 0.01\n",
    "event_sequence = intrinsic_event_algo(df, 'mid', dc_threshold)\n",
    "print(event_sequence)\n",
    "\n",
    "\n",
    "########################################################################\n",
    "########### TRADING STRATEGY DC REVERSAL ###############################\n",
    "##########################################################################\n",
    "\n",
    "\n",
    "def dc_reversal_strategy(event_sequence, df):\n",
    "initial_equity = 1.0 # Initial capital\n",
    "position = None\n",
    "pnl = []\n",
    "equity_curve= initial_equity\n",
    "\n",
    "for index, event in event_sequence.iterrows():\n",
    "if event['type'] != 'DC':\n",
    "continue\n",
    "\n",
    "event_time = event['timestamp']\n",
    "price_data = df[df['timestamp'] == event_time].iloc[0]\n",
    "\n",
    "# Follow the reverse of directional change\n",
    "if event['direction'] == 'up':\n",
    "signal = 'sell'\n",
    "elif event['direction'] == 'down':\n",
    "signal = 'buy'\n",
    "\n",
    "if position:\n",
    "# Calculate the PnL\n",
    "if position['type'] == 'buy':\n",
    "pnl.append(price_data['bid'] - position['price'])\n",
    "elif position['type'] == 'sell':\n",
    "pnl.append(position['price'] - price_data['ask'])\n",
    "\n",
    "position = None\n",
    "\n",
    "# Open a position\n",
    "if signal == 'buy':\n",
    "position = {'price': price_data['ask'], 'type': 'buy'}\n",
    "elif signal == 'sell':\n",
    "position = {'price': price_data['bid'], 'type': 'sell'}\n",
    "\n",
    "# Calculate the final PnL and the equity curve\n",
    "total_pnl = sum(pnl)\n",
    "equity_curve = [initial_equity + sum(pnl[:i+1]) for i in range(len(pnl))]\n",
    "equity_curve.insert(0,initial_equity)\n",
    "return {'pnl': pnl, 'total_pnl': total_pnl, 'equity_curve': equity_curve}\n",
    "\n",
    "# Execute the strategy\n",
    "results = dc_reversal_strategy(event_sequence, df)\n",
    "\n",
    "print(\"PnL per Trade:\", results['pnl'])\n",
    "print(\"Total PnL:\", results['total_pnl'])\n",
    "print(\"Equity Curve:\", results['equity_curve'])\n",
    "\n",
    "#######################################################################\n",
    "########## TRY TO OPTIMISE the choice of DC threshold #################\n",
    "\n",
    "import numpy as np\n",
    "\n",
    "def optimal(df,min_DC,max_DC,step):\n",
    "best= None\n",
    "max_pnl=float(\"-inf\")\n",
    "\n",
    "for threshold in np.arange(min_DC,max_DC,step):\n",
    "event_sequence =intrinsic_event_algo(df, 'mid', threshold)\n",
    "results=dc_reversal_strategy(event_sequence,df)\n",
    "\n",
    "if results['total_pnl']> max_pnl:\n",
    "max_pnl=results['total_pnl']\n",
    "best_threshold = threshold\n",
    "return best_threshold, max_pnl\n",
    "min_DC=0.01\n",
    "max_DC=0.05\n",
    "step=0.01\n",
    "optimal_DC,max_pnl=optimal(df,min_DC,max_DC,step)\n",
    "print(\"OPTIMAL DC THRESHOLD:\",optimal_DC)\n",
    "print(\"max pnl\",max_pnl)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'getcwd' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-1-80c72379bb65>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mgetcwd\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m: name 'getcwd' is not defined"
     ]
    }
   ],
   "source": [
    "getcwd()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
